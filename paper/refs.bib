@online{Coq-typing-rules,
  author = {},
  title = {Typing rules --- {Coq} 8.17.0 documentation},
  url = {https://coq.inria.fr/distrib/current/refman/language/cic.html},
  note = {Accessed {April 6, 2023}},
}

@online{Coq-inductive-defs,
  author = {},
  title = {Inductive types and recursive functions --- {Coq} 8.17.0 documentation},
  url = {https://coq.inria.fr/distrib/current/refman/language/core/inductive.html#inductive-definitions},
  urldate = {April 6, 2023},
}

@article{Dargent,
  author = {Chen, Zilin and Lafont, Ambroise and O'Connor, Liam and Keller, Gabriele and McLaughlin, Craig and Jackson, Vincent and Rizkallah, Christine},
  title = {Dargent: A Silver Bullet for Verified Data Layout Refinement},
  year = {2023},
  issue_date = {January 2023},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {7},
  number = {POPL},
  url = {https://doi.org/10.1145/3571240},
  doi = {10.1145/3571240},
  abstract = {Systems programmers need fine-grained control over the memory layout of data structures, both to produce performant code and to comply with well-defined interfaces imposed by existing code, standardised protocols or hardware. Code that manipulates these low-level representations in memory is hard to get right. Traditionally, this problem is addressed by the implementation of tedious marshalling code to convert between compiler-selected data representations and the desired compact data formats. Such marshalling code is error-prone and can lead to a significant runtime overhead due to excessive copying. While there are many languages and systems that address the correctness issue, by automating the generation and, in some cases, the verification of the marshalling code, the performance overhead introduced by the marshalling code remains. In particular for systems code, this overhead can be prohibitive. In this work, we address both the correctness and the performance problems. We present a data layout description language and data refinement framework, called Dargent, which allows programmers to declaratively specify how algebraic data types are laid out in memory. Our solution is applied to the Cogent language, but the general ideas behind our solution are applicable to other settings. The Dargent framework generates C code that manipulates data directly with the desired memory layout, while retaining the formal proof that this generated C code is correct with respect to the functional semantics. This added expressivity removes the need for implementing and verifying marshalling code, which eliminates copying, smoothens interoperability with surrounding systems, and increases the trustworthiness of the overall system.},
  journal = {Proc. ACM Program. Lang.},
  month = {jan},
  articleno = {47},
  numpages = {27},
  keywords = {certifying compiler, systems programming, data refinement}
}
