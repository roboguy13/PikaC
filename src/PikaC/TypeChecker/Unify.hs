module PikaC.TypeChecker.Unify
  (Equal
  ,getRepr
  ,unify
  )
  where

import PikaC.TypeChecker.Monad
import PikaC.Syntax.Type
import PikaC.Syntax.Pika.Layout
import PikaC.Ppr

import Unbound.Generics.LocallyNameless

import Control.Monad
import Control.Applicative
import Data.Functor

import Data.List
import Data.Maybe

import Control.Lens

import Control.Monad.Reader

data Equal = TypeName :=: Type
  deriving (Show)

lookupEqual :: TypeName -> [Equal] -> Maybe Type
lookupEqual _ [] = Nothing
lookupEqual t ((x :=: y) : rest)
  | x == t = Just y
  | otherwise = lookupEqual t rest

-- | Get a representative type variable from the type signature, since we
-- know those type variables will be in scope. If it is a concrete layout,
-- it gives back that layout name
getRepr :: [TypeName] -> TypeName -> [Equal] -> Check s Type
getRepr sigVars v eqs = do
  lAdts <- asks _layoutAdts
  let unifyEqs = getUnifyEqs lAdts eqs

  case lookupVarUnifyEq unifyEqs v of
    Nothing -> undefined
    Just (UnifyEq _ (Just layout)) -> pure $ LayoutId layout
    Just (UnifyEq xs Nothing) ->
      case sigVars `intersect` xs of
        (v':_) -> pure $ TyVar v'
        _ -> checkError $ text "Ambiguous type variable" $$ nest 2 (ppr v)

getUnifyEqs :: [(String, AdtName)] -> [Equal] -> [UnifyEq]
getUnifyEqs layoutAdts = rewrite go . mapMaybe (singleUnifyEq layoutAdts)
  where
    go :: [UnifyEq] -> Maybe [UnifyEq]
    go [] = Nothing
    go [ueq] = Nothing
    go (ueq1 : ueq2 : rest) =
      case combine ueq1 ueq2 of
        Just ueq ->
          case go rest of
            Nothing -> Just $ ueq : rest
            Just r -> Just $ ueq : r
        Nothing -> (ueq1:) <$> go (ueq2 : rest)

-- Equalities generated by unification
data UnifyEq = UnifyEq [TypeName] (Maybe LayoutName)
  deriving (Show)

lookupVarUnifyEq :: [UnifyEq] -> TypeName -> Maybe UnifyEq
lookupVarUnifyEq xs t = find go xs
  where
    go (UnifyEq ys _) = t `elem` ys

combine :: UnifyEq -> UnifyEq -> Maybe UnifyEq
combine (UnifyEq xs _) (UnifyEq ys _)
  | not (any (`elem` xs) ys) = Nothing

combine (UnifyEq xs (Just adt)) (UnifyEq ys (Just adt'))
  | adt /= adt' = Nothing
  | otherwise = Just $ UnifyEq (xs ++ ys) (Just adt)

combine (UnifyEq xs adt) (UnifyEq ys adt') =
  Just $ UnifyEq (xs ++ ys) (adt <|> adt')

singleUnifyEq :: [(String, AdtName)] -> Equal -> Maybe UnifyEq
singleUnifyEq layoutAdts (v :=: LayoutId layout) =
  Just $ UnifyEq [v] (Just layout)
singleUnifyEq layoutAdts (v :=: TyVar v') = Just $ UnifyEq [v, v'] Nothing
singleUnifyEq _ _ = Nothing


unify :: Type -> Type -> [Equal] -> Check s [Equal]
unify x y eqs
  | x `aeq` y = pure eqs
unify (TyVar x) y eqs = unifyVar x y eqs
unify x (TyVar y) eqs = unifyVar y x eqs
unify x y eqs
  | isBaseType x || isBaseType y = checkError $ text "Cannot unify" $$ nest 2 (ppr x) $$ text "with" $$ nest 2 (ppr y)

unify (FnType x1 y1) (FnType x2 y2) eqs =
  unify y1 y2 =<< unify x1 x2 eqs

unify (LayoutId x) (LayoutId y) eqs
  | x == y = pure eqs
  | otherwise = checkError $ text "Cannot unify" $$ nest 2 (ppr x) $$ text "with" $$ nest 2 (ppr y)

unify t1@(ForAll bnd1) t2@(ForAll bnd2) eqs = do
  ((v1, Embed adt1), body1) <- unbind bnd1
  ((v2, Embed adt2), body2) <- unbind bnd2
  if adt1 == adt2
    then unify body1 body2 =<< unify (TyVar v1) (TyVar v2) eqs
    else checkError $ text "Cannot unify" $$ nest 2 (ppr t1) $$ text "with" $$ nest 2 (ppr t2)

unify t1@(GhostApp ty1 xs1) t2@(GhostApp ty2 xs2) eqs = do
  if and $ zipWith (==) xs1 xs2
    then unify ty1 ty2 eqs
    else checkError $ text "Cannot unify" $$ nest 2 (ppr t1) $$ text "with" $$ nest 2 (ppr t2)

unifyVar :: TypeName -> Type -> [Equal] -> Check s [Equal]
unifyVar x (TyVar y) eqs
  | x `aeq` y = pure eqs
unifyVar x y eqs
  | Just x' <- lookupEqual x eqs = unify x' y eqs
unifyVar x (TyVar y) eqs
  | Just y' <- lookupEqual y eqs = unify (TyVar x) y' eqs
unifyVar x y eqs = do
  occurs <- occursIn x y eqs
  if occurs
    then checkError $ text "Occurs check failed:" $$ nest 2 (ppr x) $$ text "occurs in" $$ nest 2 (ppr y)
    else pure $ (x :=: y) : eqs

occursIn :: TypeName -> Type -> [Equal] -> Check s Bool
occursIn v (TyVar v') eqs
  | v' == v = pure True
  | Just t' <- lookupEqual v' eqs = occursIn v t' eqs
occursIn v t eqs
  | isBaseType t = pure False
occursIn v (FnType t1 t2) eqs = liftA2 (||) (occursIn v t1 eqs) (occursIn v t2 eqs)
occursIn v (LayoutId {}) eqs = pure False
occursIn v (ForAll bnd) eqs = do
  ((v', _), body) <- unbind bnd
  if v /= v'
    then occursIn v body eqs
    else pure False
occursIn v (GhostApp t _) eqs = occursIn v t eqs

